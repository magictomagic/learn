#include<iostream>

//  左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
//  右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。右值要么是字面常量， 要么是在表达式求值过程中创建的临时对象
//  一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。

// &&右值是临时值，无地址，值传递
// 左值有地址
// 引用，别名
// 可通过&取->得到的东西其实是静态的指针

// 左值引用的基本语法：type &引用名 = 左值表达式；
// 右值引用的基本语法type &&引用名 = 右值表达式；
int main(){
    int a = 0;
    // int &b = a;
    std::cout<<&a<<std::endl;
    // std::cout<<&b<<std::endl;
    int* const c = &a;
    int* d = &a;
    std::cout<<c<<std::endl;
    std::cout<<d<<std::endl;
    // 取到相同的地址

    // 两种方式
    // 初始化时，右值引用一定要用一个右值表达式绑定
    const int &a1 = 1;
    int && b1 = 1;

    std::cout<<b1<<std::endl;  // 1

    // 可以用左值表达式修改右值引用的所引用临时对象的值
    b1 = 2;
    std::cout<<b1<<std::endl;  // 2
    
    // int && c1 = b1;  // 无法将右值引用绑定到左值
    int && c1 = std::move(b1);  // 将左值引用强制转化为右值引用
    // std::move语句可以将左值变为右值而避免拷贝构造。
    // std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。

    int d1[1] = {b1};
    d1[0] ++;
    std::cout<<d1[0]<<std::endl;  // 3
    std::cout<<b1<<std::endl;  // 2

}